<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>File Compressor – PNG steganography</title>
<style>
    /* ---------- BASIC STYLES (unchanged) ---------- */
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:Arial,Helvetica,sans-serif;background:#1a1a1a;color:#e0e0e0;min-height:100vh;padding:20px}
    .container{max-width:900px;margin:auto;background:#2d2d2d;border-radius:8px;padding:30px;box-shadow:0 4px 6px rgba(0,0,0,.3)}
    h1{color:#00ff6e;font-size:28px;margin-bottom:25px}
    .tabs{display:flex;gap:10px;margin-bottom:25px;border-bottom:2px solid #3d3d3d}
    .tab{padding:12px 24px;background:none;border:none;color:#888;cursor:pointer;font-size:15px;border-bottom:3px solid transparent;transition:.2s}
    .tab:hover{color:#bbb}
    .tab.active{color:#00ff6e;border-bottom-color:#00ff6e}
    .tab-content{display:none}
    .tab-content.active{display:block}
    .upload-zone{border:2px dashed #555;border-radius:6px;padding:40px;text-align:center;cursor:pointer;background:#252525;margin-bottom:20px;transition:.3s}
    .upload-zone:hover{border-color:#00ff6e;background:#2a2a2a}
    .upload-zone.dragover{border-color:#00ff6e;background:#2f3f2f}
    .upload-zone p{margin:8px 0}
    .upload-zone .main-text{font-size:16px;color:#ccc}
    .upload-zone .sub-text{font-size:13px;color:#777}
    input[type=file]{display:none}
    .settings{background:#252525;padding:20px;border-radius:6px;margin-bottom:20px}
    .setting-row{margin-bottom:15px}
    .setting-row:last-child{margin-bottom:0}
    label{display:block;margin-bottom:6px;color:#bbb;font-size:14px}
    select, input[type=password], input[type=text]{width:100%;padding:10px;background:#1a1a1a;border:1px solid #3d3d3d;border-radius:4px;color:#e0e0e0;font-size:14px}
    select:focus, input:focus{outline:none;border-color:#00ff6e}
    .checkbox-row{display:flex;align-items:center;gap:8px}
    input[type=checkbox]{width:18px;height:18px;cursor:pointer}
    .checkbox-row label{margin:0;cursor:pointer}
    .btn{width:100%;padding:14px;background:#00ff6e;color:#1a1a1a;border:none;border-radius:4px;font-size:15px;font-weight:600;cursor:pointer;transition:.2s}
    .btn:hover{background:#00e062}
    .btn:disabled{background:#3d3d3d;color:#666;cursor:not-allowed}
    .progress-section{display:none;margin-top:20px;padding:20px;background:#252525;border-radius:6px}
    .progress-section.active{display:block}
    .progress-bar-container{width:100%;height:8px;background:#1a1a1a;border-radius:4px;overflow:hidden;margin-bottom:12px}
    .progress-bar-fill{height:100%;background:#00ff6e;width:0%;transition:width .3s ease}
    .progress-info{display:flex;justify-content:space-between;font-size:13px;color:#aaa;margin-bottom:15px}
    .image-preview{margin-top:20px;text-align:center}
    .image-preview canvas{max-width:100%;border:1px solid #3d3d3d;border-radius:4px;background:#1a1a1a}
    .file-list{max-height:180px;overflow-y:auto;background:#1a1a1a;padding:12px;border-radius:4px;margin-top:15px;font-size:13px}
    .file-item{padding:6px 0;border-bottom:1px solid #2d2d2d;color:#aaa}
    .file-item:last-child{border-bottom:none}
    .info-panel{background:#1f2f1f;padding:15px;border-radius:4px;margin-bottom:20px;border-left:3px solid #00ff6e;display:none}
    .info-panel.show{display:block}
    .info-panel h3{color:#00ff6e;font-size:15px;margin-bottom:10px}
    .info-panel p{margin:5px 0;font-size:13px;color:#bbb}
    .download-btn{margin-top:15px;background:#0088ff}
    .download-btn:hover{background:#006dd9}
    .footer{text-align:center;margin-top:30px;color:#555;font-size:12px}
    ::-webkit-scrollbar{width:8px}
    ::-webkit-scrollbar-track{background:#1a1a1a}
    ::-webkit-scrollbar-thumb{background:#3d3d3d;border-radius:4px}
    ::-webkit-scrollbar-thumb:hover{background:#555}
</style>
</head>
<body>
<div class="container">
    <h1>File Compressor</h1>

    <!-- ---------- TABS ---------- -->
    <div class="tabs">
        <button class="tab active" onclick="switchTab('compress')">Compress to PNG</button>
        <button class="tab" onclick="switchTab('extract')">Extract from PNG</button>
    </div>

    <!-- ---------- COMPRESS TAB ---------- -->
    <div id="compress-tab" class="tab-content active">
        <div class="upload-zone" id="compress-drop" onclick="document.getElementById('file-input').click()">
            <p class="main-text">Click to select files or drag them here</p>
            <p class="sub-text">Multiple files will be combined into a single PNG</p>
        </div>
        <input type="file" id="file-input" multiple>

        <div class="file-list" id="selected-files" style="display:none"></div>

        <div class="settings">
            <div class="setting-row">
                <label>Compression Method (currently only DEFLATE is used)</label>
                <select id="compress-method">
                    <option value="deflate">DEFLATE – fast, good ratio</option>
                </select>
            </div>

            <div class="setting-row">
                <label>Output filename</label>
                <input type="text" id="output-name" placeholder="compressed.png">
            </div>

            <div class="setting-row">
                <label>Password (optional – AES‑GCM)</label>
                <input type="password" id="compress-pass" placeholder="Leave empty for no password">
            </div>

            <div class="setting-row checkbox-row">
                <input type="checkbox" id="size-limit" checked>
                <label for="size-limit">Enable 50 MB size limit</label>
            </div>
        </div>

        <button class="btn" id="compress-start" onclick="startCompress()" disabled>Start Compression</button>

        <div class="progress-section" id="compress-progress">
            <div class="progress-info">
                <span id="compress-status">Processing…</span>
                <span id="compress-percent">0 %</span>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar-fill" id="compress-bar"></div>
            </div>
            <div class="image-preview">
                <canvas id="preview-canvas"></canvas>
            </div>
            <button class="btn download-btn" id="download-btn" onclick="downloadImage()" style="display:none">Download PNG</button>
        </div>
    </div>

    <!-- ---------- EXTRACT TAB ---------- -->
    <div id="extract-tab" class="tab-content">
        <div class="upload-zone" id="extract-drop" onclick="document.getElementById('png-input').click()">
            <p class="main-text">Click to select PNG file or drag it here</p>
            <p class="sub-text">Select a compressed PNG to extract its contents</p>
        </div>
        <input type="file" id="png-input" accept=".png">

        <div class="info-panel" id="png-info">
            <h3>PNG Information</h3>
            <div id="png-details"></div>
        </div>

        <div class="settings">
            <div class="setting-row">
                <label>Password (if protected)</label>
                <input type="password" id="extract-pass" placeholder="Leave empty if no password">
            </div>
        </div>

        <button class="btn" id="extract-start" onclick="startExtract()" disabled>Extract Files</button>

        <div class="progress-section" id="extract-progress">
            <div class="progress-info">
                <span id="extract-status">Processing…</span>
                <span id="extract-percent">0 %</span>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar-fill" id="extract-bar"></div>
            </div>
        </div>
    </div>

    <div class="footer">Made by Olibot13 and ChatGPT</div>
</div>

<!-- ---------- DEPENDENCIES ---------- -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<script>
/* -------------------------------------------------
   GLOBAL STATE
--------------------------------------------------- */
let selectedFiles = [];    // files for compression
let selectedPNG   = null;  // PNG chosen for extraction
let generatedBlob = null;  // Blob that holds the final PNG

/* -------------------------------------------------
   TAB SWITCHING
--------------------------------------------------- */
function switchTab(tab){
    document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c=>c.classList.remove('active'));

    if(tab==='compress'){
        document.querySelector('.tab:first-child').classList.add('active');
        document.getElementById('compress-tab').classList.add('active');
    }else{
        document.querySelector('.tab:last-child').classList.add('active');
        document.getElementById('extract-tab').classList.add('active');
    }
}

/* -------------------------------------------------
   DRAG‑AND‑DROP HANDLERS
--------------------------------------------------- */
const compressDrop = document.getElementById('compress-drop');
compressDrop.addEventListener('dragover',e=>{e.preventDefault();compressDrop.classList.add('dragover');});
compressDrop.addEventListener('dragleave',()=>compressDrop.classList.remove('dragover'));
compressDrop.addEventListener('drop',e=>{
    e.preventDefault();compressDrop.classList.remove('dragover');
    handleFiles(Array.from(e.dataTransfer.files));
});

const extractDrop = document.getElementById('extract-drop');
extractDrop.addEventListener('dragover',e=>{e.preventDefault();extractDrop.classList.add('dragover');});
extractDrop.addEventListener('dragleave',()=>extractDrop.classList.remove('dragover'));
extractDrop.addEventListener('drop',e=>{
    e.preventDefault();extractDrop.classList.remove('dragover');
    if(e.dataTransfer.files.length) handlePNG(e.dataTransfer.files[0]);
});

/* -------------------------------------------------
   INPUT CHANGE LISTENERS
--------------------------------------------------- */
document.getElementById('file-input').addEventListener('change',e=>handleFiles(Array.from(e.target.files)));
document.getElementById('png-input').addEventListener('change',e=>{
    if(e.target.files.length) handlePNG(e.target.files[0]);
});

/* -------------------------------------------------
   FILE SELECTION (compress)
--------------------------------------------------- */
function handleFiles(files){
    selectedFiles = files;
    const list = document.getElementById('selected-files');
    list.innerHTML = files.map(f=>`<div class="file-item">${f.name} – ${formatBytes(f.size)}</div>`).join('');
    list.style.display = 'block';
    document.getElementById('compress-start').disabled = false;

    // Pre‑fill a default output name if the user left it empty
    if(!document.getElementById('output-name').value){
        document.getElementById('output-name').value = 'compressed.png';
    }
}

/* -------------------------------------------------
   PNG SELECTION (extract)
--------------------------------------------------- */
function handlePNG(file){
    if(!file.name.toLowerCase().endsWith('.png')){
        alert('Please select a PNG file');
        return;
    }
    selectedPNG = file;
    document.getElementById('extract-start').disabled = false;

    const info = document.getElementById('png-info');
    const details = document.getElementById('png-details');
    details.innerHTML = `
        <p>File: ${file.name}</p>
        <p>Size: ${formatBytes(file.size)}</p>
    `;
    info.classList.add('show');
}

/* -------------------------------------------------
   COMPRESSION LOGIC
--------------------------------------------------- */
async function startCompress(){
    if(selectedFiles.length===0) return;

    const password = document.getElementById('compress-pass').value.trim();
    const limitEnabled = document.getElementById('size-limit').checked;
    const outputName = document.getElementById('output-name').value || 'compressed.png';

    // UI prep
    document.getElementById('compress-start').disabled = true;
    const progSec = document.getElementById('compress-progress');
    progSec.classList.add('active');
    updateProgress('compress',0,'Creating ZIP');

    try{
        // ------- 1. Build the ZIP -------
        const zip = new JSZip();
        for(const f of selectedFiles){
            const data = await f.arrayBuffer();
            zip.file(f.name, data);
        }
        const zipUint8 = await zip.generateAsync({type:'uint8array',compression:'DEFLATE',compressionOptions:{level:9}});
        updateProgress('compress',30,'ZIP created');

        // ------- 2. Optional encryption -------
        let payload = zipUint8;
        let encryptedFlag = 0;
        if(password){
            encryptedFlag = 1;
            payload = await encryptData(payload,password);
        }
        updateProgress('compress',55,'Payload ready');

        // ------- 3. Build binary layout (flag + length + data) -------
        const lengthBytes = new Uint8Array(4);
        const view = new DataView(lengthBytes.buffer);
        view.setUint32(0,payload.length);               // big‑endian 32‑bit length
        const header = new Uint8Array(1+4);             // flag + length
        header[0] = encryptedFlag;
        header.set(lengthBytes,1);
        const fullData = new Uint8Array(header.length + payload.length);
        fullData.set(header,0);
        fullData.set(payload,header.length);
        updateProgress('compress',70,'Data packed');

        // ------- 4. Encode data into a canvas (RGB only) -------
        const pixelsNeeded = Math.ceil(fullData.length / 3);    // 3 bytes per pixel (R,G,B)
        const dimension = Math.max(100, Math.ceil(Math.sqrt(pixelsNeeded)));
        const canvas = document.getElementById('preview-canvas');
        canvas.width = dimension;
        canvas.height = dimension;
        const ctx = canvas.getContext('2d');
        const imgData = ctx.createImageData(dimension,dimension);
        const dst = imgData.data; // RGBA Uint8ClampedArray

        // Fill everything with opaque white (so any unused pixel is harmless)
        for(let i=0;i<dst.length;i+=4){
            dst[i]=255;dst[i+1]=255;dst[i+2]=255;dst[i+3]=255;
        }

        // Write the payload bytes into R,G,B channels sequentially
        let srcIdx = 0;
        for(let i=0;i<fullData.length;i++){
            const pixelIdx = Math.floor(i/3);
            const channel = i%3; // 0=R,1=G,2=B
            dst[pixelIdx*4 + channel] = fullData[i];
        }

        ctx.putImageData(imgData,0,0);
        updateProgress('compress',90,'Canvas ready');

        // ------- 5. Export canvas as PNG -------
        generatedBlob = await new Promise(res=>canvas.toBlob(res,'image/png'));
        updateProgress('compress',100,'Done');

        document.getElementById('download-btn').style.display='block';
    }catch(err){
        alert('Compression failed: '+err.message);
        progSec.classList.remove('active');
        document.getElementById('compress-start').disabled = false;
    }
}

/* -------------------------------------------------
   DOWNLOAD THE GENERATED PNG
--------------------------------------------------- */
function downloadImage(){
    if(!generatedBlob) return;
    const outputName = document.getElementById('output-name').value || 'compressed.png';
    const url = URL.createObjectURL(generatedBlob);
    const a = document.createElement('a');
    a.href = url; a.download = outputName;
    a.click();
    URL.revokeObjectURL(url);
}

/* -------------------------------------------------
   EXTRACTION LOGIC
--------------------------------------------------- */
async function startExtract(){
    if(!selectedPNG) return;

    const password = document.getElementById('extract-pass').value.trim();
    document.getElementById('extract-start').disabled = true;
    const progSec = document.getElementById('extract-progress');
    progSec.classList.add('active');

    try{
        updateProgress('extract',5,'Loading PNG');

        const img = await loadImage(selectedPNG);
        const canvas = document.createElement('canvas');
        canvas.width = img.width; canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img,0,0);
        const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
        const src = imgData.data; // RGBA

        // ------- 1. Read flag + length (first 5 bytes) -------
        updateProgress('extract',25,'Reading header');
        const flag = src[0]; // R of pixel 0
        const lenBytes = new Uint8Array(4);
        // length bytes are stored in the next three channels + the R channel of pixel 1
        //   pixel 0 : R=flag, G=length0, B=length1
        //   pixel 1 : R=length2, G=length3, B=...
        lenBytes[0] = src[1]; // G of pixel 0
        lenBytes[1] = src[2]; // B of pixel 0
        lenBytes[2] = src[4]; // R of pixel 1
        lenBytes[3] = src[5]; // G of pixel 1
        const dataLength = new DataView(lenBytes.buffer).getUint32(0);

        // ------- 2. Extract payload (starting at byte index 5) -------
        updateProgress('extract',45,'Extracting payload');
        const payload = new Uint8Array(dataLength);
        let dstIdx = 0;
        for(let i=5;i<5+dataLength;i++){
            const pixelIdx = Math.floor(i/3);
            const channel = i%3; // 0=R,1=G,2=B
            payload[dstIdx++] = src[pixelIdx*4 + channel];
        }

        // ------- 3. Decrypt if needed -------
        let zipBytes = payload;
        if(flag===1){
            if(!password){
                throw new Error('File is encrypted – password required');
            }
            updateProgress('extract',65,'Decrypting');
            zipBytes = await decryptData(payload,password);
        }

        // ------- 4. Load ZIP and trigger downloads -------
        updateProgress('extract',80,'Opening ZIP');
        const zip = await JSZip.loadAsync(zipBytes);
        const entries = Object.keys(zip.files);
        for(const name of entries){
            const fileObj = zip.files[name];
            if(fileObj.dir) continue; // skip folders
            const blob = await fileObj.async('blob');
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = name;
            a.click();
            URL.revokeObjectURL(url);
        }

        updateProgress('extract',100,'Done');
        setTimeout(()=>{ progSec.classList.remove('active'); document.getElementById('extract-start').disabled = false; },1500);
    }catch(err){
        alert('Extraction failed: '+err.message);
        progSec.classList.remove('active');
        document.getElementById('extract-start').disabled = false;
    }
}

/* -------------------------------------------------
   UI PROGRESS HELPER
--------------------------------------------------- */
function updateProgress(type, percent, status){
    document.getElementById(`${type}-status`).textContent = status;
    document.getElementById(`${type}-percent`).textContent = Math.round(percent)+' %';
    document.getElementById(`${type}-bar`).style.width = percent+'%';
}

/* -------------------------------------------------
   ENCRYPTION / DECRYPTION (AES‑GCM, PBKDF2)
--------------------------------------------------- */
async function encryptData(data,password){
    const enc = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey('raw',enc.encode(password),'PBKDF2',false,['deriveKey']);
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const key = await crypto.subtle.deriveKey(
        {name:'PBKDF2',salt,iterations:150000,hash:'SHA-256'},
        keyMaterial,
        {name:'AES-GCM',length:256},
        false,
        ['encrypt']
    );
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const ciphertext = await crypto.subtle.encrypt({name:'AES-GCM',iv},key,data);
    const out = new Uint8Array(salt.length+iv.length+ciphertext.byteLength);
    out.set(salt,0);
    out.set(iv,salt.length);
    out.set(new Uint8Array(ciphertext),salt.length+iv.length);
    return out;
}

async function decryptData(data,password){
    const enc = new TextEncoder();
    const salt = data.slice(0,16);
    const iv   = data.slice(16,28);
    const ct   = data.slice(28);
    const keyMaterial = await crypto.subtle.importKey('raw',enc.encode(password),'PBKDF2',false,['deriveKey']);
    const key = await crypto.subtle.deriveKey(
        {name:'PBKDF2',salt,iterations:150000,hash:'SHA-256'},
        keyMaterial,
        {name:'AES-GCM',length:256},
        false,
        ['decrypt']
    );
    const plain = await crypto.subtle.decrypt({name:'AES-GCM',iv},key,ct);
    return new Uint8Array(plain);
}

/* -------------------------------------------------
   IMAGE LOADER UTILITY
--------------------------------------------------- */
function loadImage(file){
    return new Promise((res,rej)=>{
        const img = new Image();
        img.onload = ()=>{ URL.revokeObjectURL(img.src); res(img); };
        img.onerror = rej;
        img.src = URL.createObjectURL(file);
    });
}

/* -------------------------------------------------
   BYTE‑FORMATTER
--------------------------------------------------- */
function formatBytes(b){
    if(b===0) return '0 B';
    const k=1024;
    const sizes=['B','KB','MB','GB','TB'];
    const i=Math.floor(Math.log(b)/Math.log(k));
    return (b/k**i).toFixed(2)+' '+sizes[i];
}
</script>
</body>
</html>
